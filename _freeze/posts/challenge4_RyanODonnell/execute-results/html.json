{
  "hash": "ea4393120d4b812c238e076dd4e9a21a",
  "result": {
    "markdown": "---\ntitle: \"Challenge 4 Solution\"\nauthor: \"Ryan O'Donnell\"\ndesription: \"More data wrangling: pivoting\"\ndate: \"9/29/22\"\nformat:\n  html:\n    toc: true\n    code-fold: true\n    code-copy: true\n    code-tools: true\ncategories:\n  - challenge_4\n  - ryan_odonnell\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(readxl)\nlibrary(lubridate)\n\nknitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE)\n```\n:::\n\n\n## Challenge Overview\n\nToday's challenge is to:\n\n1)  read in a data set, and describe the data set using both words and any supporting information (e.g., tables, etc)\n2)  tidy data (as needed, including sanity checks)\n3)  identify variables that need to be mutated\n4)  mutate variables and sanity check all mutations\n\n## Read in data\n\nRead in one (or more) of the following datasets, using the correct R package and command.\n\n-   abc_poll.csv ⭐\n-   poultry_tidy.xlsx or organiceggpoultry.xls⭐⭐\n-   FedFundsRate.csv⭐⭐⭐\n-   hotel_bookings.csv⭐⭐⭐⭐\n-   debt_in_trillions.xlsx ⭐⭐⭐⭐⭐\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndebt_orig <- read_xlsx(\"_data/debt_in_trillions.xlsx\")\n\ndebt_orig\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 74 × 8\n   `Year and Quarter` Mortgage HE Revolvin…¹ Auto …² Credi…³ Stude…⁴ Other Total\n   <chr>                 <dbl>         <dbl>   <dbl>   <dbl>   <dbl> <dbl> <dbl>\n 1 03:Q1                  4.94         0.242   0.641   0.688   0.241 0.478  7.23\n 2 03:Q2                  5.08         0.26    0.622   0.693   0.243 0.486  7.38\n 3 03:Q3                  5.18         0.269   0.684   0.693   0.249 0.477  7.56\n 4 03:Q4                  5.66         0.302   0.704   0.698   0.253 0.449  8.07\n 5 04:Q1                  5.84         0.328   0.72    0.695   0.260 0.446  8.29\n 6 04:Q2                  5.97         0.367   0.743   0.697   0.263 0.423  8.46\n 7 04:Q3                  6.21         0.426   0.751   0.706   0.33  0.41   8.83\n 8 04:Q4                  6.36         0.468   0.728   0.717   0.346 0.423  9.04\n 9 05:Q1                  6.51         0.502   0.725   0.71    0.364 0.394  9.21\n10 05:Q2                  6.70         0.528   0.774   0.717   0.374 0.402  9.49\n# … with 64 more rows, and abbreviated variable names ¹​`HE Revolving`,\n#   ²​`Auto Loan`, ³​`Credit Card`, ⁴​`Student Loan`\n```\n:::\n:::\n\n\n### Briefly describe the data\n\n\"debt_in_trillions\" appears to be a table of different types of debt held by year and quarter. The types of debt include Mortgage, HE Revolving, Auto Loan, Credit Card, Student Loan, and Other. Year and quarter is stored in a single column and there is a total column as well.\n\n## Tidy Data (as needed)\n\nIs your data already tidy, or is there work to be done? Be sure to anticipate your end result to provide a sanity check, and document your work here.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get rid of total row and separate Year & Quarter\n\ndebt <- debt_orig %>%\n  select(-`Total`) %>%\n  separate(`Year and Quarter`, into = c(\"Year\", \"Quarter\"), convert = TRUE)\n\n# sanity check - expected number of rows\n\nnrow(debt) * (ncol(debt) - 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 444\n```\n:::\n\n```{.r .cell-code}\n# pivot data\n\ndebt_pivoted <- debt %>%\n  pivot_longer(col = c(`Mortgage`, `HE Revolving`, `Auto Loan`, `Credit Card`, `Student Loan`, `Other`),\n               names_to = \"Debt Type\",\n               values_to = \"Debt in Trillions\")\n\n# Check Expected Number\n\nnrow(debt_pivoted)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 444\n```\n:::\n\n```{.r .cell-code}\nhead(debt_pivoted)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 4\n   Year Quarter `Debt Type`  `Debt in Trillions`\n  <int> <chr>   <chr>                      <dbl>\n1     3 Q1      Mortgage                   4.94 \n2     3 Q1      HE Revolving               0.242\n3     3 Q1      Auto Loan                  0.641\n4     3 Q1      Credit Card                0.688\n5     3 Q1      Student Loan               0.241\n6     3 Q1      Other                      0.478\n```\n:::\n:::\n\n\n## Identify variables that need to be mutated\n\n*Are there any variables that require mutation to be usable in your analysis stream? For example, are all time variables correctly coded as dates? Are all string variables reduced and cleaned to sensible categories? Do you need to turn any variables into factors and reorder for ease of graphics and visualization?*\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Fix the year, create a column that is stored as a date\n  debt_tidy <- debt_pivoted %>% \n  mutate(Year = Year + 2000, \n  \"Month\" = str_replace_all(Quarter, c(\"Q1\" = \"1\", \"Q2\" = \"4\", \"Q3\" = \"6\", \"Q4\" = \"10\")),\n  \"Date\" = make_date(`Year`, `Month`, \"01\"),\n  .before = `Debt Type`)\n\ndebt_tidy\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 444 × 6\n    Year Quarter Month Date       `Debt Type`  `Debt in Trillions`\n   <dbl> <chr>   <chr> <date>     <chr>                      <dbl>\n 1  2003 Q1      1     2003-01-01 Mortgage                   4.94 \n 2  2003 Q1      1     2003-01-01 HE Revolving               0.242\n 3  2003 Q1      1     2003-01-01 Auto Loan                  0.641\n 4  2003 Q1      1     2003-01-01 Credit Card                0.688\n 5  2003 Q1      1     2003-01-01 Student Loan               0.241\n 6  2003 Q1      1     2003-01-01 Other                      0.478\n 7  2003 Q2      4     2003-04-01 Mortgage                   5.08 \n 8  2003 Q2      4     2003-04-01 HE Revolving               0.26 \n 9  2003 Q2      4     2003-04-01 Auto Loan                  0.622\n10  2003 Q2      4     2003-04-01 Credit Card                0.693\n# … with 434 more rows\n```\n:::\n:::\n\n\nI had to fix the year column type when I split it from the quarter. In this step, I used mutate to add 2000 to it to make it the correct year. When thinking about visualizing the data, I realized that we might want to convert the Quarter/Year combo into a date so that we could plot it on a timeline. I am assuming that these Quarters represent the calendar year and not a fiscal year so I set the quarters to January, April, July, and October. \n\n### Categorize\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(debt_tidy, aes(`Date`, `Debt in Trillions`, color = fct_reorder2(`Debt Type`, `Date`, `Debt in Trillions`))) + \n  geom_line() + \n  scale_x_date() +\n  scale_y_log10() + \n  labs(y = \"Debt in Trillions ($USD)\", title = \"Debt 2003-2021\", color = \"Debt Type\")\n```\n\n::: {.cell-output-display}\n![](challenge4_RyanODonnell_files/figure-html/categorize-1.png){width=672}\n:::\n:::\n\n\nI reordered the Debt Type so that the colors would match the order of the lines. I also set the y axis to logarithmic since there was such a big difference between Mortgage and the rest of the lines. With a logarithmic scale, you can see the variations in the lines that would otherwise be squished at the bottom.\n\n### Recategorizing again for practice\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#| label: plotting again\n\n# group by debt type and sum for the year\ndebt_barplot <- debt_tidy %>%\n  group_by(`Year`, `Debt Type`) %>%\n  summarize(\"Debt\" = sum(`Debt in Trillions`))\n\n# plot\n\nggplot(debt_barplot, \n       aes(`Year`, `Debt`, fill = fct_rev(\n         fct_reorder2(`Debt Type`, `Year`, `Debt`)))) + \n  geom_col() + \n  labs(y = \"Debt in Trillions ($USD)\", title = \"Type of Debt by Year\", fill = \"Debt Type\")\n```\n\n::: {.cell-output-display}\n![](challenge4_RyanODonnell_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\nI thought I would try a different visualization type that involved some more factorizing to get the chart to look nice. I summed the debt type by year (using the existing year column, I did not challenge myself to regroup by year using the newly generated date column). I first factored the Debt Type like I did which orders highest to lowest on the final x,y value. This put the largest chunks on top, so I reversed the order since I believe it is generally good practice to put the largest at the bottom. ",
    "supporting": [
      "challenge4_RyanODonnell_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}