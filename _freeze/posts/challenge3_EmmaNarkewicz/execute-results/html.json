{
  "hash": "eb28e82bf1b4eaaaf79a931de254abd0",
  "result": {
    "markdown": "---\ntitle: \"Emma Narkewicz Challenge 3\"\nauthor: \"Emma Narkewicz\"\ndesription: \"Tidy Data: Pivoting\"\ndate: \"10/10/2022\"\nformat:\n  html:\n    toc: true\n    code-fold: true\n    code-copy: true\n    code-tools: true\ncategories:\n  - challenge_3\n  - emma_narkewicz\n  - australian_marriage\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\nknitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE)\n```\n:::\n\n\n## Challenge Overview\n\nToday's challenge is to:\n\n1.  read in a data set, and describe the data set using both words and any supporting information (e.g., tables, etc)\n2.  identify what needs to be done to tidy the current data\n3.  anticipate the shape of pivoted data\n4.  pivot the data into tidy format using `pivot_longer`\n\n::: panel-tabset\n## Read in Data\n\nI chose to read in the Australian Marriage Survey Data. The original data set was in an excel format with 4 sheets: Contents, Table 1, Table 2, & Explanatory Notes. I read in specifically the Table 2 sheet of Federal Election Divisions, as it includes information from the State & Territory data in Table 1.\n\nFor each federal election district, there is data for each eligible participant if there was:\n\n-   A clear response, unclear response, of no response\n\n-   If a response was clear, was it yes or no.\n\nIn this read in step I skipped the first 7 rows which included titles and blank row not necessary to the analysis. I assigned column names using col_names() to be able to easily identify and delete certain columns using select. I removed the blank column H, the total, and percentage columns, and response clear column. The total & percentages can be re-constructed from the other columns, and clear responses numbers are redundant to the yes and no columns (clear responses = no + yes). The original sheet had 16 columns and 191 rows. At this step in the read in, there are now 5 columns and 184 rows.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Read In Data Pt1\nlibrary(readxl)\nAus_Marriage_Data <-read_excel(\"_data/australian_marriage_law_postal_survey_2017_-_response_final.xls\", \n        sheet = 3, \n        skip = 7, \n        col_names = c(\"District\", \"Yes\", \"Percent\", \"No\", \"Percent\", \"Total\", \"Total_Percent\", \"Blank\", \"Response_Clear\", \"Response_Clear_Percent\", \"Unclear_Response\", \"Unclear_Response_Percent\",\"Non_Response\", \"Non_Response_Percent\", \"Total\", \"Total_Percent\")) %>%\n        select(!contains(\"Percent\")) %>%\n        select(!contains(\"Total\")) %>%\n        select(!contains(\"Blank\")) %>%\n        select(!contains(\"Response_Clear\")) \n      \nAus_Marriage_Data\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 184 × 5\n   District                    Yes    No Unclear_Response Non_Response\n   <chr>                     <dbl> <dbl>            <dbl>        <dbl>\n 1 New South Wales Divisions    NA    NA               NA           NA\n 2 Banks                     37736 46343              247        20928\n 3 Barton                    37153 47984              226        24008\n 4 Bennelong                 42943 43215              244        19973\n 5 Berowra                   48471 40369              212        16038\n 6 Blaxland                  20406 57926              220        25883\n 7 Bradfield                 53681 34927              202        17261\n 8 Calare                    54091 35779              285        25342\n 9 Chifley                   32871 46702              263        28180\n10 Cook                      47505 38804              229        18713\n# … with 174 more rows\n```\n:::\n:::\n\n\nAt this point I have removed redundant and blanks columns and the first 7 rows, but there are still additional rows that need to be dealt with.There are 1) Total rows for divisions 2) Blank rows between divisions, 3) The bottom rows of the sheet, that contain notes, and Australia wide data.\n\nTo begin, I used the head function to remove the bottom 10 rows of the table, which contain notes and Australian based data. This left me with the total and blank rows to get rid of. I knew to use filter() function to select row but I was at a loss for how to specify which rows I wanted without the contains() starts_with() and ends_with() functions I have learned to love working with select(). After finding nothing in the *R For Data Science* textbook, I turned to Professor Rolfe's Challenge 3 solutions.\n\nThe drop_na(), str_detect(), and str_starts() function were used in the Challenge 3 Solution, so I embarked on a quest to understand why these functions were applicable here.\n\n-   drop_na() drop rows containing missing values.\n\n    -   This is ideal for removing the blank rows between Divisions. As I only want to remove these rows and not rows with missing data in other columns, I specify the District_Division column in the drop_na() function.\n\n-   str_detect and str_starts( ) are functions within the stringr package. str_detect() identifies the presence of pattern match in a a string and str_starts() identifies the presence of a pattern match in the beginning of a string\n\n    -   I want to identify rows that contain total, so I will attempt to use str_detect(Divisions, \"total\") within the filter.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Remove Notes & Australia Wide data\nAus_Marriage_Data <- head(Aus_Marriage_Data, -10) %>%\n#Remove blank rows between Divisions using drop)na\n   drop_na(\"District\") %>%\n#Remove total rows using function\n  filter(!str_detect(District,\"(Total)\"))\n\nAus_Marriage_Data\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 158 × 5\n   District                    Yes    No Unclear_Response Non_Response\n   <chr>                     <dbl> <dbl>            <dbl>        <dbl>\n 1 New South Wales Divisions    NA    NA               NA           NA\n 2 Banks                     37736 46343              247        20928\n 3 Barton                    37153 47984              226        24008\n 4 Bennelong                 42943 43215              244        19973\n 5 Berowra                   48471 40369              212        16038\n 6 Blaxland                  20406 57926              220        25883\n 7 Bradfield                 53681 34927              202        17261\n 8 Calare                    54091 35779              285        25342\n 9 Chifley                   32871 46702              263        28180\n10 Cook                      47505 38804              229        18713\n# … with 148 more rows\n```\n:::\n:::\n\n\n## Briefly Describe the Data\n\nAfter removing redundant rows and columns, I now have a data set with the dimensions of 144 x 5. The 5 columns are: District\\_, Yes, No, Unclear_Response, and Non_Response. The district division column contains mostly districts, with the division at the top of every list of districts. Before pivoting the data, I need to separate out district and division.\n\n## Separate District and Division\n\nThis transformation was advanced for me, and required once again referencing Professor Rolfe's Challenge 3 Solutions to accomplish it. I know how to fill missing data and how to separate a column when 2 pieces of data are in one row, but this case is neither of those. There are are no rows with missing data to fill and Division are written in a separate row than districts, as opposed to being written District_Division.\n\nI show this out step by step to make sure I understand why each step is necessary and can apply it moving forward to other data sets when applicable.\n\nBased on the Challenge 3 Solution, we can overcome this using case_when to first create a new Divisions column whenever a row ends with \"Divisions\" (e.g., New South Wales Divisions). This works, but I don't like that this new Division column is all the way to the right, so I use relocate() to move it before District column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Creating new division column\nAus_Marriage <- Aus_Marriage_Data %>%\n  mutate(Division = case_when(\n    str_ends(District, \"Divisions\") ~ District)\n  )%>%\n  relocate(`Division`, .before = `District`)\n\nAus_Marriage\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 158 × 6\n   Division                  District                  Yes    No Uncle…¹ Non_R…²\n   <chr>                     <chr>                   <dbl> <dbl>   <dbl>   <dbl>\n 1 New South Wales Divisions New South Wales Divisi…    NA    NA      NA      NA\n 2 <NA>                      Banks                   37736 46343     247   20928\n 3 <NA>                      Barton                  37153 47984     226   24008\n 4 <NA>                      Bennelong               42943 43215     244   19973\n 5 <NA>                      Berowra                 48471 40369     212   16038\n 6 <NA>                      Blaxland                20406 57926     220   25883\n 7 <NA>                      Bradfield               53681 34927     202   17261\n 8 <NA>                      Calare                  54091 35779     285   25342\n 9 <NA>                      Chifley                 32871 46702     263   28180\n10 <NA>                      Cook                    47505 38804     229   18713\n# … with 148 more rows, and abbreviated variable names ¹​Unclear_Response,\n#   ²​Non_Response\n```\n:::\n:::\n\n\nNext, I use the fill() function to fill the empty Division column rows. This is possible because the Division applies to all the districts in a row up until the next division.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Fill down the divisions\nAus_Marriage <- Aus_Marriage %>%\n fill(Division)\n  \nAus_Marriage\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 158 × 6\n   Division                  District                  Yes    No Uncle…¹ Non_R…²\n   <chr>                     <chr>                   <dbl> <dbl>   <dbl>   <dbl>\n 1 New South Wales Divisions New South Wales Divisi…    NA    NA      NA      NA\n 2 New South Wales Divisions Banks                   37736 46343     247   20928\n 3 New South Wales Divisions Barton                  37153 47984     226   24008\n 4 New South Wales Divisions Bennelong               42943 43215     244   19973\n 5 New South Wales Divisions Berowra                 48471 40369     212   16038\n 6 New South Wales Divisions Blaxland                20406 57926     220   25883\n 7 New South Wales Divisions Bradfield               53681 34927     202   17261\n 8 New South Wales Divisions Calare                  54091 35779     285   25342\n 9 New South Wales Divisions Chifley                 32871 46702     263   28180\n10 New South Wales Divisions Cook                    47505 38804     229   18713\n# … with 148 more rows, and abbreviated variable names ¹​Unclear_Response,\n#   ²​Non_Response\n```\n:::\n:::\n\n\nThis is nifty! I now have a column of districts, and a column of divisions, which I wanted. Looking at the tibble, I still have the pesky row where the Division is in the district column and there are no response data. To get rid of this, I can use filter() and str_detect(), specifying that I want to remove any row in which the District column contains \"Divisions\".\n\n\n::: {.cell}\n\n```{.r .cell-code}\nAus_Marriage <- filter(Aus_Marriage, !str_detect(`District`, \"Divisions\"))\n\nAus_Marriage\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 150 × 6\n   Division                  District    Yes    No Unclear_Response Non_Response\n   <chr>                     <chr>     <dbl> <dbl>            <dbl>        <dbl>\n 1 New South Wales Divisions Banks     37736 46343              247        20928\n 2 New South Wales Divisions Barton    37153 47984              226        24008\n 3 New South Wales Divisions Bennelong 42943 43215              244        19973\n 4 New South Wales Divisions Berowra   48471 40369              212        16038\n 5 New South Wales Divisions Blaxland  20406 57926              220        25883\n 6 New South Wales Divisions Bradfield 53681 34927              202        17261\n 7 New South Wales Divisions Calare    54091 35779              285        25342\n 8 New South Wales Divisions Chifley   32871 46702              263        28180\n 9 New South Wales Divisions Cook      47505 38804              229        18713\n10 New South Wales Divisions Cowper    57493 38317              315        25197\n# … with 140 more rows\n```\n:::\n:::\n\n\nWoohoo! We did it. I leaned on the Challenge 3 Solutions, but was able to think critically through why I applied each step. Now lets pivot some data!\n\n## Anticipate Pivoted Data Dimensions\n\nI want to pivot the Yes, No, Unclear_Response, and Non_Response columns into \"Response_Type\", and \"Response_Count\" columns. A case would then be a response count for a response type, in a district, in a division.\n\nI expect my pivoted data_set to have 4 columns, Division, District, Response Type, and Response_Count.\n\nMy un-pivoted data set has 150 rows and I am pivoting 4 columns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n150 * 4\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 600\n```\n:::\n:::\n\n\nI therefor expect by pivoted data set to have dimensions of 600 rows by 4 columns.\n\n## Pivot the Data\n\n\n::: {.cell}\n\n```{.r .cell-code}\nAus_Marriage_tidy <-pivot_longer(Aus_Marriage, col = c(\"Yes\", \"No\", \"Unclear_Response\", \"Non_Response\"),\n                 names_to=\"Response_Type\",\n                 values_to = \"Response_Count\")\n\nAus_Marriage_tidy\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 600 × 4\n   Division                  District  Response_Type    Response_Count\n   <chr>                     <chr>     <chr>                     <dbl>\n 1 New South Wales Divisions Banks     Yes                       37736\n 2 New South Wales Divisions Banks     No                        46343\n 3 New South Wales Divisions Banks     Unclear_Response            247\n 4 New South Wales Divisions Banks     Non_Response              20928\n 5 New South Wales Divisions Barton    Yes                       37153\n 6 New South Wales Divisions Barton    No                        47984\n 7 New South Wales Divisions Barton    Unclear_Response            226\n 8 New South Wales Divisions Barton    Non_Response              24008\n 9 New South Wales Divisions Bennelong Yes                       42943\n10 New South Wales Divisions Bennelong No                        43215\n# … with 590 more rows\n```\n:::\n:::\n\n\nAwesome, the dimensions of the pivoted table set are indeed 600 x 4. This data set is tidy and ready to work with to perform further statistic or graphical analysis.\n\n## Graphing for Practice\n\nI tried to create a bar chart of the Response_Count of each Response_Type per division,  but that did not work. You can see in the bar chart below that each Response_Type color of the bar is equal in size, whereas looking at the data, the response counts vary a lot by Response_Type. The Unclear_Response bar segments should be much smaller than the Yes, No, and Non_Response bar segments, but they appear to be equal in size here. Reviewing the  *R for Data Science* textbook, R auto-generates the Counts in bar charts, and it seems that whatever it is using as counts is not the Response_Counts I'm looking for.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Attempting Bar Chart of Response Count by Division\n\nggplot(data = Aus_Marriage_tidy) + geom_bar(mapping = aes(x=`Division`, fill = `Response_Type`)) + labs(title=\"Wrong Bar Chart of Australian Marriage Survey Responses by Division\")\n```\n\n::: {.cell-output-display}\n![](challenge3_EmmaNarkewicz_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\nI will attempt to override the incorrect default count by setting the stat of geom_bar() from the default count to identity, allowing me to specify the y = Response_Count.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Attempting another bar chart of Response Count by Division\n\nggplot(data = Aus_Marriage_tidy) + geom_bar(mapping = aes(x=`Division`, y = `Response_Count`, fill = `Response_Type`), stat = \"identity\") + labs(title=\"Correct Bar Chart of Australian Marriage Survey Responses by Division\")\n```\n\n::: {.cell-output-display}\n![](challenge3_EmmaNarkewicz_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\nCool, it worked! I'm glad I played around with graphing to learn I need to be wary of trusting the default bar chart stats. I can now see that in all divisions \"yes\" was the most popular response type, followed by no, then non_response. Unclear responses exist but make up a fraction of a percentage of all responses, and are represented as a very thin teal line on the bar chart.\n:::\n",
    "supporting": [
      "challenge3_EmmaNarkewicz_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}